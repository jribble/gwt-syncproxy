/*
 * Copyright www.gdevelop.com.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */
package com.gdevelop.gwt.syncrpc;


import java.io.IOException;
import java.lang.reflect.Proxy;
import java.net.CookieManager;
import java.net.URISyntaxException;
import java.util.Map;

import org.apache.http.client.CookieStore;
import org.apache.http.impl.client.BasicCookieStore;

import com.google.gwt.user.client.rpc.AsyncCallback;
import com.google.gwt.user.client.rpc.RemoteServiceRelativePath;


/**
 * Sync Proxy for GWT RemoteService
 * Usage:
 * MyServiceInterface myService = newProxyInstance(MyServiceInterface.class,
 *    "http://localhost:8888/myapp/", "myServiceServlet", policyName);
 *  where policyName is the file name (with gwt.rpc extenstion) generated
 *  by GWT RPC backend
 *
 * Or
 * MyServiceInterface myService = newProxyInstance(MyServiceInterface.class,
 *    "http://localhost:8888/myapp/", "myServiceServlet");
 * In this case, the SyncProxy search for the appropriate policyName file in
 * the system classpath
 *
 * If not specified, SyncProxy uses a <em>default</em> {@link CookieManager}
 * to manage client-server communication session
 *
 * To perform multi-session:
 * CookieManager cookieManager = LoginUtils.loginAppEngine(...);
 * MyServiceInterface myService = newProxyInstance(MyServiceInterface.class,
 *    "http://localhost:8888/myapp/", "myServiceServlet", cookieManager);
 * @see com.gdevelop.gwt.syncrpc.test.ProfileServiceTest example
 */
public class SyncProxy {
  /**
   * Map from ServiceInterface class name to Serialization Policy name
   */
  private static final Map<String, String> POLICY_MAP = RpcPolicyFinder.searchPolicyFileInClassPath();
  
  private static final CookieStore DEFAULT_COOKIE_STORE = new BasicCookieStore();
  
  private static ThreadLocal < AsyncCallback<Long> > responseReadCallback = new ThreadLocal<AsyncCallback<Long>>();
  
  /**
  * Create a new Proxy for the specified <code>serviceIntf</code>
  * @param serviceIntf The remote service interface
  * @param moduleBaseURL Base URL
  * @param remoteServiceRelativePath The remote service servlet relative path
  * @param policyName Policy name (*.gwt.rpc) generated by GWT RPC backend
  * @param cookieManager Used to perform session management such as login. 
  * @param waitForInvocation Used for Async RemoteService.
  * @return A new proxy object which implements the service interface serviceIntf
 * @throws URISyntaxException 
  */
  @SuppressWarnings("unchecked")
  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                        String remoteServiceRelativePath, 
                                        String policyName, 
                                        CookieStore cookieStore, 
                                        boolean waitForInvocation) throws URISyntaxException{
    if (policyName == null){
      try {
        POLICY_MAP.putAll(RpcPolicyFinder.fetchSerializationPolicyName(moduleBaseURL));
        policyName = POLICY_MAP.get(serviceIntf.getName());
      } catch (IOException e) {
        e.printStackTrace();
      }
    }

    return Proxy.newProxyInstance(SyncProxy.class.getClassLoader(), 
                new Class[]{serviceIntf}, 
                new RemoteServiceInvocationHandler(moduleBaseURL, 
                                                   remoteServiceRelativePath, 
                                                   policyName, 
                                                   cookieStore,
                                                   waitForInvocation));
  }

  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                        String remoteServiceRelativePath, 
                                        String policyName, 
                                        CookieStore cookieStore) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, 
                            remoteServiceRelativePath, policyName, 
                            cookieStore, false);
  }
  
  /**
   * Create a new Proxy for the specified service interface <code>serviceIntf</code>
   * 
   * @param serviceIntf The remote service interface
   * @param moduleBaseURL Base URL
   * @param remoteServiceRelativePath The remote service servlet relative path
   * @param policyName Policy name (*.gwt.rpc) generated by GWT RPC backend
   * @return A new proxy object which implements the service interface serviceIntf
 * @throws URISyntaxException 
   */
  @SuppressWarnings("unchecked")
  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                       String remoteServiceRelativePath, 
                                       String policyName) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, remoteServiceRelativePath, 
                            policyName, DEFAULT_COOKIE_STORE);
  }

  /**
  * Create a new Proxy for the specified service interface <code>serviceIntf</code>
  * 
  * @param serviceIntf The remote service interface
  * @param moduleBaseURL Base URL
  * @param remoteServiceRelativePath The remote service servlet relative path
  * @return A new proxy object which implements the service interface serviceIntf
 * @throws URISyntaxException 
  */
  @SuppressWarnings("unchecked")
  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                       String remoteServiceRelativePath) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, remoteServiceRelativePath, 
                            POLICY_MAP.get(serviceIntf.getName()), DEFAULT_COOKIE_STORE);
  }
  /**
  * Create a new Proxy for the specified service interface <code>serviceIntf</code>
  * 
  * @param serviceIntf The remote service interface
  * @param moduleBaseURL Base URL
  * @param remoteServiceRelativePath The remote service servlet relative path
  * @param cookieManager Used to perform session management such as login. 
  * @return A new proxy object which implements the service interface serviceIntf
 * @throws URISyntaxException 
  */
  @SuppressWarnings("unchecked")
  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                       String remoteServiceRelativePath, 
                                        CookieStore cookieStore) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, remoteServiceRelativePath, 
                            POLICY_MAP.get(serviceIntf.getName()), cookieStore);
  }

  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                        CookieStore cookieStore, 
                                        boolean waitForInvocation) throws URISyntaxException{
    RemoteServiceRelativePath relativePathAnn = (RemoteServiceRelativePath)
      serviceIntf.getAnnotation(RemoteServiceRelativePath.class);
    if (serviceIntf.getName().endsWith("Async")){
      // Try determine remoteServiceRelativePath from the 'sync' version of the Async one
      String className = serviceIntf.getName();
      try {
        Class clazz = Class.forName(className.substring(0, className.length()-5));
        relativePathAnn = (RemoteServiceRelativePath)
              clazz.getAnnotation(RemoteServiceRelativePath.class);
      } catch (ClassNotFoundException e) {
        e.printStackTrace();
      }
    }
    if (relativePathAnn == null){
      throw new RuntimeException(serviceIntf + " does not has a RemoteServiceRelativePath annotation");
    }
    String remoteServiceRelativePath = relativePathAnn.value();
    return newProxyInstance(serviceIntf, moduleBaseURL, remoteServiceRelativePath, 
                            POLICY_MAP.get(serviceIntf.getName()), cookieStore, waitForInvocation);
  }

  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                        CookieStore cookieStore) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, cookieStore, false);
  }
  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, DEFAULT_COOKIE_STORE);
  }

  public static Object newProxyInstance(Class serviceIntf, String moduleBaseURL, 
                                        boolean waitForInvocation) throws URISyntaxException{
    return newProxyInstance(serviceIntf, moduleBaseURL, 
                            DEFAULT_COOKIE_STORE, waitForInvocation);
  }
  
  /**
   * The response read callback is called after a method is called and the response has been read from
   * the server, but before the response has been deserialized.  The Long parameter is the number of bytes
   * in the response.
   * This callback is useful for to time the call and response of a RPC method without including deserialization time.
   * @param callback
   */
  public static void setResponseReadCallback ( AsyncCallback<Long> callback ) {
     responseReadCallback.set ( callback );
  }

  /**
   * The response read callback is called after a method is called and the response has been read from
   * the server, but before the response has been deserialized.  The Long parameter is the number of bytes
   * in the response.
   * This callback is useful for to time the call and response of a RPC method without including deserialization time.
   * @param callback
   */
  public static AsyncCallback<Long> getResponseReadCallback ( ) {
     return responseReadCallback.get ( );
  }
}
